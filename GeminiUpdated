import org.junit.Test;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.ExpectedException;

import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentModificationException;

import static org.junit.Assert.*;
import static org.hamcrest.Matchers.*;

public class GeminiUpdated {

    // Set up a rule to test for expected exceptions (JUnit 4 style)
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    // --- Helper Classes/Interfaces for Testing ---

    /**
     * A non-comparable class to test for ClassCastException when natural ordering is used.
     */
    private static class NonComparable {
        final int value;
        NonComparable(int v) { this.value = v; }
        @Override
        public boolean equals(Object o) {
            return o instanceof NonComparable && ((NonComparable) o).value == this.value;
        }
        @Override
        public int hashCode() {
            return value;
        }
    }

    /**
     * A Comparator that orders Integers in reverse (Max-Heap behavior).
     */
    private static class ReverseIntegerComparator implements Comparator<Integer>, Serializable {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2.compareTo(o1);
        }
    }

    /**
     * A Comparator for NonComparable objects.
     */
    private static class NonComparableComparator implements Comparator<NonComparable>, Serializable {
        @Override
        public int compare(NonComparable o1, NonComparable o2) {
            return Integer.compare(o1.value, o2.value);
        }
    }

    // --- Constructor Tests ---

    @Test
    public void testDefaultConstructor() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        assertNotNull(pq);
        assertEquals(0, pq.size());
        assertNull(pq.comparator());
    }

    @Test
    public void testInitialCapacityConstructor() {
        PriorityQueue<Integer> pq = new PriorityQueue<>(5);
        assertNotNull(pq);
        assertEquals(0, pq.size());
        assertNull(pq.comparator());
    }

    @Test
    public void testInitialCapacityConstructor_InvalidCapacity() {
        thrown.expect(IllegalArgumentException.class);
        new PriorityQueue<Integer>(0);
    }

    @Test
    public void testComparatorConstructor() {
        Comparator<Integer> cmp = new ReverseIntegerComparator();
        PriorityQueue<Integer> pq = new PriorityQueue<>(cmp);
        assertNotNull(pq);
        assertEquals(cmp, pq.comparator());
    }

    @Test
    public void testCapacityAndComparatorConstructor() {
        Comparator<Integer> cmp = new ReverseIntegerComparator();
        PriorityQueue<Integer> pq = new PriorityQueue<>(5, cmp);
        assertNotNull(pq);
        assertEquals(cmp, pq.comparator());
    }

    @Test
    public void testCollectionConstructor_NaturalOrderingAndHeapify() {
        List<Integer> list = Arrays.asList(5, 1, 4, 8, 2);
        PriorityQueue<Integer> pq = new PriorityQueue<>(list);
        assertEquals(5, pq.size());
        assertEquals(1, (int) pq.poll()); // Min-heap: smallest element first
        assertEquals(2, (int) pq.poll());
    }

    @Test
    public void testCollectionConstructor_FromPriorityQueue() {
        PriorityQueue<Integer> original = new PriorityQueue<>(new ReverseIntegerComparator());
        original.add(10);
        original.add(20);

        PriorityQueue<Integer> copy = new PriorityQueue<>(original);
        assertEquals(2, copy.size());
        assertEquals(original.comparator(), copy.comparator());
        assertEquals(20, (int) copy.poll()); // Max-heap: largest element first
    }

    @Test
    public void testCollectionConstructor_FromSortedSet() {
        SortedSet<Integer> ss = new TreeSet<>(new ReverseIntegerComparator());
        ss.add(10);
        ss.add(20);

        PriorityQueue<Integer> pq = new PriorityQueue<>(ss);
        assertEquals(2, pq.size());
        assertThat(pq.comparator(), instanceOf(ReverseIntegerComparator.class));
        assertEquals(20, (int) pq.poll()); // Max-heap ordering from SortedSet
    }

    @Test
    public void testCollectionConstructor_NullsInCollection() {
        thrown.expect(NullPointerException.class);
        List<Integer> listWithNull = Arrays.asList(1, 2, null);
        new PriorityQueue<>(listWithNull);
    }

    @Test
    public void testCollectionConstructor_NonComparable() {
        thrown.expect(ClassCastException.class);
        List<Object> nonComparableList = Arrays.<Object>asList(new NonComparable(1), new NonComparable(2));
        new PriorityQueue<>(nonComparableList); // Natural ordering is implicitly used
    }

    // --- Basic Queue Operations (Add, Offer, Peek, Poll, Size) ---

    @Test
    public void testOfferAndPoll_MinHeap() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        assertTrue(pq.offer(10));
        assertTrue(pq.offer(5));
        assertTrue(pq.offer(15));
        assertEquals(3, pq.size());
        assertEquals(5, (int) pq.poll()); // Smallest is 5
        assertEquals(10, (int) pq.poll());
        assertEquals(15, (int) pq.poll());
        assertNull(pq.poll());
        assertEquals(0, pq.size());
    }

    @Test
    public void testOfferAndPoll_MaxHeap() {
        PriorityQueue<Integer> pq = new PriorityQueue<>(new ReverseIntegerComparator());
        pq.offer(10);
        pq.offer(5);
        pq.offer(15);
        assertEquals(15, (int) pq.poll()); // Largest is 15
        assertEquals(10, (int) pq.poll());
        assertEquals(5, (int) pq.poll());
    }

    @Test
    public void testAdd_EquivalentToOffer() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        assertTrue(pq.add(1));
        assertEquals(1, (int) pq.peek());
    }

    @Test
    public void testOffer_SiftUpPathComparable() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.offer(20);
        pq.offer(15);
        pq.offer(10);
        pq.offer(5); // Should sift all the way up to root (0)
        assertEquals(5, (int) pq.peek());
    }

    @Test
    public void testOffer_SiftUpPathComparator() {
        // Max-heap: adding 25 should sift up to the root
        PriorityQueue<Integer> pq = new PriorityQueue<>(new ReverseIntegerComparator());
        pq.offer(5);
        pq.offer(10);
        pq.offer(15);
        pq.offer(25);
        assertEquals(25, (int) pq.peek());
    }

    @Test
    public void testPoll_SiftDownPathComparable() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(10, 20, 30, 40, 50));
        assertEquals(10, (int) pq.poll()); // 20 moves to root, then sifts down
        assertEquals(20, (int) pq.peek());
    }

    @Test
    public void testPoll_SiftDownPathComparator() {
        // Max-heap
        PriorityQueue<Integer> pq = new PriorityQueue<>(new ReverseIntegerComparator());
        pq.addAll(Arrays.asList(50, 40, 30, 20, 10));
        assertEquals(50, (int) pq.poll()); // 40 moves to root, sifts down
        assertEquals(40, (int) pq.peek());
    }

    @Test
    public void testPeek_EmptyQueue() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        assertNull(pq.peek());
    }

    @Test
    public void testPoll_EmptyQueue() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        assertNull(pq.poll());
    }

    @Test
    public void testElement_EmptyQueue() {
        thrown.expect(NoSuchElementException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.element(); // AbstractQueue implementation throws NoSuchElementException
    }

    @Test
    public void testAdd_NullElement() {
        thrown.expect(NullPointerException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(null);
    }

    @Test
    public void testOffer_NullElement() {
        thrown.expect(NullPointerException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.offer(null);
    }

    @Test
    public void testAdd_NonComparableElement() {
        thrown.expect(ClassCastException.class);
        PriorityQueue<Object> pq = new PriorityQueue<>();
        pq.add(new Integer(1));
        pq.add(new NonComparable(2)); // Throws ClassCastException
    }

    // Test automatic growth of the internal array
    @Test
    public void testCapacityGrowth() {
        PriorityQueue<Integer> pq = new PriorityQueue<>(1); // Initial capacity 1
        pq.add(1);
        pq.add(2); // Should trigger grow
        pq.add(3); // Should trigger grow
        assertEquals(3, pq.size());
        assertEquals(1, (int) pq.poll());
    }

    @Test
    public void testClear() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 2, 3));
        pq.clear();
        assertEquals(0, pq.size());
        assertNull(pq.peek());
    }

    // --- Search and Removal Operations (contains, remove, removeAt) ---

    @Test
    public void testContains() {
        NonComparable nc1 = new NonComparable(1);
        NonComparable nc2 = new NonComparable(2);
        NonComparable nc3 = new NonComparable(3);

        PriorityQueue<NonComparable> pq = new PriorityQueue<>(new NonComparableComparator());
        pq.add(nc1);
        pq.add(nc2);

        assertTrue(pq.contains(nc1));
        assertTrue(pq.contains(nc2));
        assertFalse(pq.contains(nc3));
        assertFalse(pq.contains(null));
    }

    @Test
    public void testRemove_HeadElement() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(5, 10, 15));
        assertTrue(pq.remove(5)); // Remove head
        assertEquals(10, (int) pq.peek());
        assertEquals(2, pq.size());
        assertFalse(pq.contains(5));
    }

    @Test
    public void testRemove_InternalElement_SiftDown() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(5, 10, 15, 20, 25, 30));
        assertTrue(pq.remove(10)); // Remove element at index 1, trigger siftDown
        assertEquals(5, (int) pq.peek()); // Head is still 5
        assertEquals(5, pq.size());
        assertFalse(pq.contains(10));
    }

    @Test
    public void testRemove_LastElement() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(5, 10, 15));
        assertTrue(pq.remove(15)); // Remove last element
        assertEquals(5, (int) pq.peek());
        assertEquals(2, pq.size());
    }

    @Test
    public void testRemove_ElementNotInQueue() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(10);
        assertFalse(pq.remove(5));
        assertEquals(1, pq.size());
    }

    // --- Array/Collection Conversion Tests ---

    @Test
    public void testToArray_ObjectType() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(5, 1, 4));
        Object[] array = pq.toArray();
        assertEquals(3, array.length);
        // Elements are not guaranteed to be sorted, but all must be present
        assertTrue(Arrays.asList(array).contains(5));
        assertTrue(Arrays.asList(array).contains(1));
        assertTrue(Arrays.asList(array).contains(4));
    }

    @Test
    public void testToArray_GenericType_SmallArray() {
        PriorityQueue<String> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList("c", "a", "b"));
        String[] result = pq.toArray(new String[0]);
        assertEquals(3, result.length);
        assertThat(Arrays.asList(result), containsInAnyOrder("a", "b", "c"));
    }

    @Test
    public void testToArray_GenericType_ExactSizeArray() {
        PriorityQueue<String> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList("c", "a", "b"));
        String[] array = new String[3];
        String[] result = pq.toArray(array);
        assertSame(array, result); // Same reference
        assertThat(Arrays.asList(result), containsInAnyOrder("a", "b", "c"));
    }

    @Test
    public void testToArray_GenericType_LargeArray() {
        PriorityQueue<String> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList("c", "a", "b"));
        String[] array = new String[5];
        String[] result = pq.toArray(array);
        assertSame(array, result); // Same reference
        assertThat(Arrays.asList(result), hasItemInArray(null)); // Should set element after end to null
        assertEquals(null, array[3]);
        assertEquals(null, array[4]);
    }

    // --- Iterator Tests ---

    @Test
    public void testIterator_Traversal() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(10, 20, 30));
        Set<Integer> iteratedElements = new HashSet<>();
        Iterator<Integer> it = pq.iterator();

        assertTrue(it.hasNext());
        iteratedElements.add(it.next());
        assertTrue(it.hasNext());
        iteratedElements.add(it.next());
        assertTrue(it.hasNext());
        iteratedElements.add(it.next());
        assertFalse(it.hasNext());

        assertEquals(3, iteratedElements.size());
        assertTrue(iteratedElements.containsAll(Arrays.asList(10, 20, 30)));
        thrown.expect(NoSuchElementException.class);
        it.next();
    }

    @Test
    public void testIterator_Remove_NormalRemoval() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(10, 20, 30));
        Iterator<Integer> it = pq.iterator();
        it.next(); // 10
        it.remove();
        assertEquals(2, pq.size());
        assertEquals(20, (int) pq.peek()); // 20 should be the new min (re-heapified)
    }

    @Test
    public void testIterator_Remove_UnluckyRemoval() {
        // Unlucky removal: removal requires a siftUp instead of siftDown,
        // resulting in the moved element being added to 'forgetMeNot' list.
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        // Set up a state where removing one element forces a swap that moves
        // an unvisited element into a visited spot, which is then added to forgetMeNot.
        pq.addAll(Arrays.asList(5, 10, 15, 20, 25, 30, 35));

        Iterator<Integer> it = pq.iterator();
        it.next(); // Cursor at 1 (element 10, or 20, depending on internal state)
        int firstElement = it.next(); // Move cursor to 2
        it.remove(); // Removes element at lastRet (1)

        // Continue iteration to trigger visiting the forgetMeNot list.
        Set<Integer> remaining = new HashSet<>();
        while(it.hasNext()) {
            remaining.add(it.next());
        }

        // Total elements were 7, 1 was removed, size is 6. All 6 must be iterated.
        assertEquals(6, remaining.size());
        assertFalse(remaining.contains(firstElement));

        // Test remove on an element from forgetMeNot
        it = pq.iterator();
        it.next(); // 5
        it.next(); // Next
        it.remove();

        int forgotten = it.next();
        assertTrue(pq.contains(forgotten)); // The forgotten element is still in the queue array
        it.remove(); // This uses PriorityQueue.removeEq(lastRetElt)
        assertFalse(pq.contains(forgotten));
    }

    @Test
    public void testIterator_Remove_IllegalState() {
        thrown.expect(IllegalStateException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        Iterator<Integer> it = pq.iterator();
        it.remove(); // Called before next()
    }

    @Test
    public void testIterator_Remove_ConsecutiveCalls() {
        thrown.expect(IllegalStateException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(1);
        Iterator<Integer> it = pq.iterator();
        it.next();
        it.remove();
        it.remove(); // Consecutive calls to remove()
    }

    @Test
    public void testIterator_ConcurrentModification() {
        thrown.expect(ConcurrentModificationException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(1);
        Iterator<Integer> it = pq.iterator();
        pq.add(2); // Structural modification
        it.next(); // Throws CME
    }

    @Test
    public void testIterator_ConcurrentModification_DuringRemove() {
        thrown.expect(ConcurrentModificationException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(1);
        pq.add(2);
        Iterator<Integer> it = pq.iterator();
        it.next();
        pq.add(3); // Structural modification
        it.remove(); // Throws CME because modCount changed unexpectedly by external add
    }

    // --- Bulk Modification Operations ---

    @Test
    public void testRemoveIf_Success() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 2, 3, 4, 5));
        assertTrue(pq.removeIf(n -> n % 2 == 0)); // Remove 2, 4
        assertEquals(3, pq.size());
        assertFalse(pq.contains(2));
        assertEquals(1, (int) pq.peek()); // New heap invariant established by heapify
    }

    @Test
    public void testRemoveIf_NoRemoval() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 3, 5));
        assertFalse(pq.removeIf(n -> n % 2 == 0));
        assertEquals(3, pq.size());
    }

    @Test
    public void testRemoveIf_ConcurrentModification() {
        thrown.expect(ConcurrentModificationException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 2, 3, 4, 5));

        pq.removeIf(n -> {
            if (n == 3) {
                // Structural modification during traversal for filtering
                pq.poll(); // Poll modifies the queue
            }
            return false;
        });
    }

    @Test
    public void testRemoveAll_Success() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 2, 3, 4, 5));
        assertTrue(pq.removeAll(Arrays.asList(1, 5, 10))); // Remove 1, 5
        assertEquals(3, pq.size());
        assertFalse(pq.contains(1));
        assertEquals(2, (int) pq.peek()); // New head is 2
    }

    @Test
    public void testRemoveAll_EmptyTargetCollection() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(1);
        assertFalse(pq.removeAll(Collections.emptyList()));
        assertEquals(1, pq.size());
    }

    @Test
    public void testRetainAll_Success() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 2, 3, 4, 5));
        assertTrue(pq.retainAll(Arrays.asList(2, 4, 6))); // Retain 2, 4
        assertEquals(2, pq.size());
        assertTrue(pq.contains(2));
        assertTrue(pq.contains(4));
        assertEquals(2, (int) pq.peek()); // New head is 2
    }

    @Test
    public void testRetainAll_EmptyResult() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 2, 3));
        assertTrue(pq.retainAll(Arrays.asList(10, 20)));
        assertTrue(pq.isEmpty());
    }

    // --- ForEach (Consumer) Test ---

    @Test
    public void testForEach_Traversal() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(10, 20, 30));
        Set<Integer> consumed = new HashSet<>();

        pq.forEach(consumed::add);

        assertEquals(3, consumed.size());
        assertTrue(consumed.containsAll(Arrays.asList(10, 20, 30)));
    }

    @Test
    public void testForEach_ConcurrentModification() {
        thrown.expect(ConcurrentModificationException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(1);
        pq.add(2);

        pq.forEach(n -> {
            if (n == 1) {
                pq.add(3); // Structural modification during traversal
            }
        });
    }

    // --- Serialization Tests (writeObject/readObject) ---

    @Test
    public void testSerialization_MinHeap() throws Exception {
        PriorityQueue<Integer> original = new PriorityQueue<>();
        original.addAll(Arrays.asList(5, 1, 4, 8));

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(original);
        oos.close();

        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        PriorityQueue<Integer> deserialized = (PriorityQueue<Integer>) ois.readObject();
        ois.close();

        assertEquals(4, deserialized.size());
        assertNull(deserialized.comparator());
        assertEquals(1, (int) deserialized.poll()); // Check heap invariant is re-established
        assertEquals(4, (int) deserialized.poll());
    }

    @Test
    public void testSerialization_MaxHeap() throws Exception {
        Comparator<Integer> cmp = new ReverseIntegerComparator();
        PriorityQueue<Integer> original = new PriorityQueue<>(cmp);
        original.addAll(Arrays.asList(5, 1, 4, 8));

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(original);
        oos.close();

        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        PriorityQueue<Integer> deserialized = (PriorityQueue<Integer>) ois.readObject();
        ois.close();

        assertEquals(4, deserialized.size());
        assertNotNull(deserialized.comparator());
        assertEquals(8, (int) deserialized.poll()); // Check heap invariant is re-established
        assertEquals(5, (int) deserialized.poll());
    }

    // --- Spliterator Tests ---

    @Test
    public void testSpliterator_Characteristics() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(1);
        Spliterator<Integer> spliterator = pq.spliterator();
        int expected = Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.NONNULL;
        assertEquals(expected, spliterator.characteristics());
    }

    @Test
    public void testSpliterator_TrySplit() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
        Spliterator<Integer> spliterator = pq.spliterator();

        Spliterator<Integer> split1 = spliterator.trySplit();
        assertNotNull(split1);
        assertEquals(3, split1.estimateSize()); // 1, 2, 3
        assertEquals(4, spliterator.estimateSize()); // 4, 5, 6, 7

        Spliterator<Integer> split2 = spliterator.trySplit();
        assertNotNull(split2);
        assertEquals(2, split2.estimateSize()); // 4, 5
        assertEquals(2, spliterator.estimateSize()); // 6, 7

        Spliterator<Integer> split3 = spliterator.trySplit();
        assertNull(split3); // Size 2 doesn't split
    }

    @Test
    public void testSpliterator_ForEachRemaining() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(10, 20, 30));
        Spliterator<Integer> spliterator = pq.spliterator();
        Set<Integer> consumed = new HashSet<>();

        spliterator.forEachRemaining(consumed::add);

        assertEquals(3, consumed.size());
        assertTrue(consumed.containsAll(Arrays.asList(10, 20, 30)));
        assertEquals(0, spliterator.estimateSize());
    }

    @Test
    public void testSpliterator_TryAdvance() {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.addAll(Arrays.asList(1, 2, 3));
        Spliterator<Integer> spliterator = pq.spliterator();
        List<Integer> consumed = new ArrayList<>();

        assertTrue(spliterator.tryAdvance(consumed::add));
        assertTrue(spliterator.tryAdvance(consumed::add));
        assertTrue(spliterator.tryAdvance(consumed::add));
        assertFalse(spliterator.tryAdvance(consumed::add));

        assertEquals(3, consumed.size());
    }

    @Test
    public void testSpliterator_ConcurrentModification() {
        thrown.expect(ConcurrentModificationException.class);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(1);
        Spliterator<Integer> spliterator = pq.spliterator();
        pq.add(2); // Structural modification
        spliterator.tryAdvance(n -> {}); // Throws CME
    }
}
